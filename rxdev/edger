#! /usr/local/bin/python3.10
# edger.py
import sys
from enum import Enum, auto

'''
This program tests a module that recognizes Acurite 609TX
temp/humidity sensor 433MHz pulse patterns and reports the codes.
It tests prototype code for an Acurite 609TX emulator that
both transmits and receives 609 sensor data from a Raspberry Pi.

For this program, "edge" means the time a gpio pulse is high
or the time it is low, not the traditional rising or falling edge
of a pulse. Language take from original code (joan).

This program reads a .ook file of pulse "edge" pairs (high/low or
low/high interval timings) and passes those edges, one-at-a-time,
to a receiver object as if they had been collected from 
as the interval between rising & falling (or falling & rising) 
pulse edges on a 433MHz receiver.

The receiver object is programmed to recognize a valid Acurite
609TX PPM pattern of pulse+interval pairs used to encode the binary
data.  It ignores packets that don't match the 609 pattern but
invokes a callback routine when it recognizes a valid packet.

================================================================

This module provides two classes to use with wireless 433MHz 
transmitters and receivers.  The tx class transmits device codes
and the rx class decodes received codes.

This customized library provides transmit & receive functions 
  specific for a 433MHz transmitter and receiver pair to emulate the
  data packets of Acurite 609 remote temp/humidity sensors.

The packet format is:
  -  constant pulse width throughout the packet
  -  3 sync pulses with pulse and gaps equal duration
  -  sync gap ("sync") following the sync pulses and before the first data bit
  -  pulse followed by gap: "short" pulse = 0, "long" pulse = 1
  -  40 data bits, each signified by a short or long gap
  -  trailing pulse after last gap (total of 44 pulses per packet)
  -  inter-packet gap (duration "gap") before next packet
  -  send the data packet "repeat" times before concluding

The transmit function allows the timings to be set as parameters,
  and a calibration function is provided to allow the calling program to
  correct for discrepancies between timing requested from the transmitter
  and timing actually seen at the receiver (known pigpio/Raspberry Pi anomaly)

  Base code was retrieved from wget abyz.me.uk/rpi/pigpio/code/_433_py.zip
    and dated 2015-10-30 and marked "Public Domain"
  Adapted by hdtodd@gmail.com, 2022.03, to mimic the Acurite 609: 
    constructed the sync pulses, gap timing, and packet length 
    to send/receive 40-bit Acurite packets
'''
# set default waveform parameters for Acurite 609 transmission timings
#  These are scaled after sending & receiving a test pulse train
#  The pigpio library timings vary depending upon system configuration,
#  So this library provides a calibration function to check
#  actual timings vs requested timings for pulses.

MSGLEN      =   40
CSIRED = "\033[31m"
CSIBLK = "\033[30m"

TOLERANCE = 5           #Timing tolerance for edge classification (as %)
TOL_MINUS = 1.0-TOLERANCE/100
TOL_PLUS  = 1.0+TOLERANCE/100

class Interval_Type(Enum):
   SYNC_GAP      =  475       #interval between sync pulses                                                             
   PULSE         =  505       #pulses are this duration, +/- 5%                                                        
   SHORT         = 1006       #interval after pulse to indicate data bit "0"                                           
   LONG          = 2000       #interval after pulse to indicate data bit "1"                                           
   SYNC          = 8940       #interval after third sync pulse, before first data                                      
   GAP           =10200       #interval after pulse that terminates last data bit                                      

class State(Enum):
   SYNC_WAIT    = auto()
   DATA_COLLECT = auto()
   PKT_GAP_WAIT = auto()

class mach():
   def __init__(self,callback=None):
      self.cb = callback
      self._reset()
      
   def _reset(self):
      self.state = State.SYNC_WAIT
      self.sync_count = 0
      self.bit_count = 0
      self.code = 0
      self.pulseavg = 0
      self.pulsecnt = 0
      self.shortavg = 0
      self.shortcnt = 0
      self.longavg  = 0
      self.longcnt  = 0
      
#This is the state-machine recognizer for Acurite PPM packets
#It accepts a token (an "edge" of length "interval" microsec)
#  and advances the machine state, depending on current state and token type
   def _next(self,token,interval=1):
      #first, accumulate metrics for possible analysis
      match token:
         case Interval_Type.PULSE:
            self.pulseavg += interval
            self.pulsecnt += 1
            return
         case Interval_Type.SHORT:
            self.shortavg += interval
            self.shortcnt += 1
         case Interval_Type.LONG:
            self.longavg  += interval
            self.longcnt  += 1

      #now evaluate state change: we have just a small number of valid transitions
      match (self.state, token):
         case (State.SYNC_WAIT, Interval_Type.SYNC_GAP):
            self.sync_count += 1
            if self.sync_count >=3:
               #should be 2 pulse+sync-gaps then 1 pulse+sync-interval
               #  so 3 pulst+sync-gaps isn't our patern: reset machine
               self._reset()

         case (State.SYNC_WAIT, Interval_Type.SYNC):
            if self.sync_count==2:
               #We've seen two sync pulse/gap pairs, and now a pulse/SYNC interval
               # So sync pattern is complete: go into data collect mode
               self.state = State.DATA_COLLECT
               self.sync_count==0
            else:
               #should have been 2 SYNC_GAPS followed by SYNC interval
               #  so <2 SYNC_GAPS followed by SYNC isn't our pattern: reset
               self._reset()

         case (State.DATA_COLLECT, Interval_Type.GAP):
            if self.bit_count==MSGLEN:
               #This is a valid packet.  Send result back to caller and reset for next
               self.cb(self.code, self.bit_count,
                       int(self.pulseavg/self.pulsecnt),
                       int(self.shortavg/self.shortcnt),
                       int(self.longavg/self.longcnt))
            else:
               print("SYNC OK; data collected != 40 bits, so packet not valid; ignore packet")
            #and reset machine in any case
            self._reset()

         case ( (State.DATA_COLLECT, Interval_Type.SHORT) | (State.DATA_COLLECT, Interval_Type.LONG) ):
            #This is a data bit, so record it
            self.bit_count += 1
            self.code <<= 1                   #make room for next bit
            self.code += 1 if token == Interval_Type.LONG else 0

         case _:
            #by default, all other cases reset recognition machine
            self._reset()

   def _get_state(self):
      return self.state, self.sync_count, self.bit_count, self.code

#   rx: A class to read wireless codes transmitted by 433 MHz transmitter
class rx():
#   def __init__(self, pi, gpio, callback=None,
#                      min_bits=8, max_bits=40, glitch=150):
   def __init__(self, valid_pkt_callback=None, min_bits=8, max_bits=40, glitch=150):
      """

      If specified the callback will be called whenever a new code
      is received.  The callback will be passed the code, the number
      of bits, the length (in us) of the gap, short pulse, and long
      pulse.

      Codes with bit lengths outside the range min_bits to max_bits
      will be ignored.

      A glitch filter will be used to remove edges shorter than
      glitch us long from the wireless stream.  This is intended
      to remove the bulk of radio noise.
      """
      self.m = mach(callback=valid_pkt_callback)
      self.min_bits = min_bits
      self.max_bits = max_bits
      self.glitch = glitch

      self._in_code = False
      self._edge = 0
      self._code = 0
      self._gap = 0
      self._ready = False
      self._edge_count = 0
      self._state = State.SYNC_WAIT
      
   def _class_edge(self,e):
      e_low = int(e*TOL_MINUS)
      e_hi  = int(e*TOL_PLUS)
      for etype in Interval_Type:
         if e_low <= etype.value <= e_hi:
            return etype
      return None

   '''
      #      self._cb = pi.callback(gpio, pigpio.EITHER_EDGE, self._cbf)

   def _timings(self, e0, e1):
      """
      Accumulates the short (t0) and long (t1) pulse length so that an
      average short/long pulse length can be calculated. The
      figures may be used to tune the transimission settings.
      """

      if self._bits:
         self._t0 += e0 if e0<e1 else e1
         self._t1 += e1 if e1>e0 else e0
      else:
         self._t0 = e0 if e0<e1 else e1
         self._t1 = e1 if e1>e0 else e0

      self._bits += 1

   def _calibrate(self, e0, e1):
      """
      The first pair of pulses is used as the template for
      subsequent pulses.  They should be one short, one long, not
      necessarily in that order.  The ratio between long and short
      should really be 2 or more.  If less than 1.5 the pulses are
      assumed to be noise.
      """
      self._bits = 0
      self._timings(e0, e1)
      self._bits = 0

      ratio = float(self._t1)/float(self._t0)

#      if ratio < 1.5:
#         self._in_code = False

      slack0 = int(0.3 * self._t0)
      slack1 = int(0.2 * self._t1)

      self._min_0 = self._t0 - slack0
      self._max_0 = self._t0 + slack0
      self._min_1 = self._t1 - slack1
      self._max_1 = self._t1 + slack1

   def _test_bit(self, e0, e1):
      """
      Returns the bit value represented by the sequence of pulses.

      0: short long
      1: long short
      2: illegal sequence
      """
      self._timings(e0, e1)

      if   ( (self._min_0 < e0 < self._max_0) and
             (self._min_1 < e1 < self._max_1) ):
         return 0
      elif ( (self._min_0 < e1 < self._max_0) and
             (self._min_1 < e0 < self._max_1) ):
         return 1
      else:
         return 2
   '''

#   def _cbf(self, g, l, t):
   def _cbf(self, edge_len):
      """
      Recognizer for PPM codes received from 433MHz receivers.

      Accumulates the data packet bit code from pulse-interval pairs, with constant pulse
      durations and with the interval length determining the value of the bit represented.  

      Edges are defined by rising and trailing edges of the electrical pulses.
      An "edge" that is the plateau is the pulse; the valley "edge" that follows is
      its interval.

      The edge length, "edge_len", can be time, in microseconds, of the
      duration of either the pulse or the inter-pulse interval. 
      We only know that it's an edge.  We assume that the first edge seen is a
      pulse (plateau defined by a rising electrical edge followed by its 
      trailing falling electrical edge. The interval that follows the pulse is 
      defined by that falling edge and the rising edge of the next electrical pulse. 

      The first two sync bits have lengths (PULSE,INTERVAL)) followed by the third
      sync bit (PULSE,SYNC).  After that, we should see (PULSE,SHORT) to
      represent a "0" data bit or (PULSE,LONG) to represent a "1" data bit.  
      The 40th bit is terminated by (PULSE,GAP) to signal the end of that packet.

      The start of packet is recognized by a sync preamble of 3 pulses.
      The end of packet is recognized when the 40th bit has been received and the gap
      that follows is at least GAP usec long.

      In short, the packet format is:
         -  constant pulse width throughout the packet
         -  3 sync pulses with intervals of nearly-equal duration after first two pulses
         -  sync interval ("sync") following the third sync pulse and before the first data bit
         -  data bit pulse followed by an interval: "short" gap = 0, "long" gap = 1
         -  trailing pulse terminates the last data-bit interval
         -  inter-packet interval (duration of at least GAP usec) before next packet
         -  transmitter sends the data packet "repeat" times before concluding transmission
      """

      # every other edge triggers an analysis of the pulse type
      self._edge_count += 1
      self._edge_count %= 2
      if self._edge_count != 0:
         #odd count -- just note the length of the first interval
         self._odd_edge_len = edge_len
      else:
         #even count -- we have pulse-interval pair
#         print("{:>5d},{:>5d}: ".format(self._odd_edge_len, edge_len), end="")
         c0 = self._class_edge(self._odd_edge_len)
         c1 = self._class_edge(edge_len)
         self.m._next(c0,self._odd_edge_len)
         self.m._next(c1,edge_len)
#         print(c0.name, c1.name)
         
         

         
'''
      edge_len = pigpio.tickDiff(self._last_edge_tick, t)
      self._last_edge_tick = t

      if edge_len < int(GAP*0.9):     # "GAP" usec with 10% error margin
         # we've got a sync or data pulse
         
         if self._in_code:
            if self.min_bits <= self._bits <= self.max_bits:
               self._lbits = self._bits
               self._lcode = self._code
               self._lgap = self._gap
               self._lt0 = int(self._t0/self._bits)
               self._lt1 = int(self._t1/self._bits)
               self._ready = True
               if self.cb is not None:
                  self.cb(self._lcode, self._lbits,
                          self._lgap, self._lt0, self._lt1)

         self._in_code = True
         self._gap = edge_len
         self._edge = 0
         self._bits = 0
         self._code = 0

      elif self._in_code:

         if self._edge == 0:
            self._e0 = edge_len
         elif self._edge == 1:
            self._calibrate(self._e0, edge_len)

         if self._edge % 2: # Odd edge.

            bit = self._test_bit(self._even_edge_len, edge_len)
            self._code = self._code << 1
            if bit == 1:
               self._code += 1
            elif bit != 0:
               self._in_code = False

         else: # Even edge.

            self._even_edge_len = edge_len

            
         self._edge += 1

   def ready(self):
      """
      Returns True if a new code is ready.
      """
      return self._ready

   def code(self):
      """
      Returns the last received code.
      """
      self._ready = False
      return self._lcode

   def details(self):
      """
      Returns details of the last received code.  The details
      consist of the code, the number of bits, the length (in us)
      of the gap, short pulse, and long pulse.
      """
      self._ready = False
      return self._lcode, self._lbits, self._lgap, self._lt0, self._lt1
'''

def cancel(self):
      """
      Cancels the wireless code receiver.
      """
      if self._cb is not None:
#         self.pi.set_glitch_filter(self.gpio, 0) # Remove glitch filter.
         self._cb.cancel()
         self._cb = None

# define optional callback for received codes to report recognized codes received
def rx_callback(code, bits, pulseavg, shortavg, longavg):
   print("\n\tFrom callback: Received msg with {:d} bits: avg pulse={:d}, avg short={:d}, avg long={:d}".format(bits, pulseavg, shortavg, longavg))
   print("\tCode = 0x{:X} = 0b{:40b} ==> ".format(code, code), end="")
   b = code.to_bytes(5,'big')
   i = b[0]
   s = b[1]>>4
   t1 = ( b[1]&0x0f )<<8
   t2 = b[2]
   t = (t1+t2)/10.0
   h = b[3]
   print("\tID=%d, s=%d, t=%5.1f, h=%d" % (i,s,t,h))

# main program

print("\nRXA609: recognize Acurite 609 pulse patterns from an .ook file\n")

if len(sys.argv)>=2:
    fn = sys.argv[1]
else:
    fn = input("Path/Name to file to be processed: ")

if not(fn.endswith(".ook") or fn.endswith(".OOK")):
    fn = fn + ".ook"
print("Processing file ", fn)

f = open(fn, "rt")
r = rx(valid_pkt_callback=rx_callback)

while (line := f.readline() ):
    if not line.startswith(";"):
        values = line.split()
        e0 = int(values[0])
        e1 = int(values[1])
#        print("{:>5d},{:>5d} --> ".format(e0,e1), end ="")
        r._cbf(e0)
        r._cbf(e1)
